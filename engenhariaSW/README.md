# Atividade 1
### O que é Engenharia de Software?
#### TEXTO 1
We see three critical differences between programming and software engineering: time, scale, and the trade-offs at play. On a software engineering project, engineers need to be more concerned with the passage of time and the eventual need for change. In a software engineering organization, we need to be more concerned about scale and efficiency, both for the software we produce as well as for the organization that is producing it. Finally, as software engineers, we are asked to make more complex decisions with higher-stakes outcomes, often based on imprecise estimates of time and growth.

#### Meus comentários sobre o texto:
1. Existem três diferenças entre programação e engenharia de software, são elas: tempo, escala e jogo de trade-off;
2. TEMPO: Em um projeto os engenheiros de software se preocupam mais com a passagem do tempo e com a eventual necessidade de mudanças;
3. ESCALA: Em uma organização os engenheiros de software se preocupam mais com escala e eficiência, tanto para o software que produz quanto para a organização que o está produzindo;
4. TRADE-OFF: Um engenheiro de software é solicitado a tomar decisões mais complexas de alto risco, muitas vezes com estimativas imprecisas de tempo e crescimento.

#### TEXTO 2
Within Google, we sometimes say, “Software engineering is programming integrated over time.” Programming is certainly a significant part of software engineering: after all, programming is how you generate new software in the first place. If you accept this distinction, it also becomes clear that we might need to delineate between programming tasks (development) and software engineering tasks (development, modification, maintenance). The addition of time adds an important new dimension to programming. Cubes aren’t squares, distance isn’t velocity. Software engineering isn’t programming.

#### Meus comentários sobre o texto:
1. A programação é uma parte significativa da engenharia de software;
2. A programação é como você gera um novo software;
3. Tarefa de programação (desenvolvimento);
4. Tarefa de engenharia de software (desenvolvimento, modificação e manutenção);
5. A adição do tempo adiciona uma nova dimensão importante a programação: Cubos não são quadrados, distância não é velocidade e engenharia de software não é programação;

# Atividade 2
### Exemplos de trade-off
1. <b> Portabilidade X Simplicidade: </b>
   O trade-off entre portabilidade e simplicidade envolve escolher entre uma linguagem de programação que é altamente portátil e pode rodar em várias plataformas, mas pode ser mais complexa, ou uma linguagem mais simples de entender e escrever, mas que pode não ser tão portátil. Como Java e Python, por exemplo.
   
3. <b> Usabilidade X Segurança: </b>
   O trade-off entre usabilidade e segurança ocorre quando desenvolver um software que é altamente usável pode comprometer a segurança e vice-versa. Usabilidade envolve facilitar a experiência do usuário, enquanto segurança envolve proteção contra ameaças. Como aplicativos de mensagens e redes sociais, por exemplo.
   
5. <b> Escalabilidade X Complexidade: </b>
   O trade-off entre escalabilidade e complexidade envolve escolher entre um sistema mais simples e fácil de entender, porém potencialmente menos escalável, e um sistema mais complexo, capaz de lidar com demandas maiores, mas também mais difícil de manter e depurar. Como programas de streamings (Netflix, Disney+, HBO, entre outros), por exemplo.

# Atividade 3
### 10 Heurísticas de Usabilidade para Design de Interface de Usuário
    https://www.nngroup.com/articles/ten-usability-heuristics/
    
### Encontre um erro e um acerto de cada heurística:
#### 1. <b> Visibilidade do Status do Sistema </b>
    Erro: Não fornecer informações claras sobre a posição do usuário e as opções disponíveis dentro do sistema, levando a uma experiência confusa.
    Acerto: Fornecer indicadores visuais intuitivos, como barras de progresso e menus organizados, para ajudar os usuários a entenderem sua posição e ações disponíveis, facilitando a navegação e a tomada de decisões.
    
#### 2. <b> Compatibilidade entre o sistema e o mundo real </b>
    Erro: Não considerar a familiaridade cultural e linguística dos usuários, o que pode resultar em escolhas inadequadas de símbolos e metáforas na interface, tornando-a menos acessível.
    Acerto: Adaptar a linguagem, símbolos e metáforas da interface para corresponder às expectativas e ao conhecimento dos usuários, facilitando a compreensão e a interação.

#### 3. <b> Controle e liberdade para o usuário </b>
    Erro: Não oferecer aos usuários a capacidade de desfazer ações ou retornar a um estado anterior, o que pode levar à frustração e à falta de confiança na interface.
    Acerto: Implementar recursos de desfazer ações para dar aos usuários o controle e a liberdade de corrigir erros, proporcionando uma sensação de segurança e melhorando a usabilidade.

#### 4. <b> Consistência e Padronização </b>
    Erro: Manter uma consistência excessiva que limita a flexibilidade e a adaptabilidade da interface.
    Acerto: Estabelecer uma base de consistência e padronização na interface, ao mesmo tempo permitindo flexibilidade quando necessário para atender a diferentes contextos e necessidades específicas, equilibrando a familiaridade e a usabilidade.

#### 5. <b> Prevenção de erros </b>
    Erro: Dependência exclusiva da prevenção de erros, sem oferecer feedback quando os erros ocorrem, deixando os usuários confusos.
    Acerto: Equilibrar a prevenção de erros com feedback eficaz quando os erros ocorrem, fornecendo medidas preventivas e instruções claras para ajudar os usuários a entender e corrigir os problemas. Isso resulta em uma experiência mais satisfatória.

#### 6. <b> Reconhecimento em vez de memorização </b>
    Erro: Sobrecarregar a interface com muitas dicas visuais, tornando-a confusa e desordenada.
    Acerto: Encontrar um equilíbrio entre fornecer dicas visuais para que os usuários possam reconhecer padrões e elementos familiares na interface, sem exagerar e manter a interface clara e simples. Isso facilita a navegação e o uso da aplicação.

#### 7. <b> Eficiência e flexibilidade de uso </b>
    Erro: Focar exclusivamente nas necessidades de um grupo de usuários (leigos ou experientes) em detrimento do outro, o que pode levar a uma interface inadequada para um público mais amplo.
    Acerto: Projetar uma interface flexível que atenda tanto aos iniciantes quanto aos usuários experientes, oferecendo uma experiência amigável e informativa para os primeiros e recursos avançados e atalhos para os últimos, proporcionando uma experiência eficaz e adaptável para todos.

#### 8. <b> Estética e design minimalista </b>
    Erro: Priorizar demais a estética e o minimalismo, sacrificando a usabilidade e removendo informações importantes, o que pode levar a uma experiência confusa para os usuários.
    Acerto: Adotar um design minimalista que elimine informações desnecessárias, mantendo o foco nas informações essenciais, desde que isso não prejudique a usabilidade e a acessibilidade da interface. Isso ajuda a tornar a interface mais eficiente ao transmitir informações importantes de forma clara.

#### 9. <b> Ajude os usuários a reconhecerem, diagnosticarem e recuperarem-se de erros </b>
    Erro: Fornecer mensagens de erro vagas e pouco informativas que não ajudam os usuários a entender o problema ou como corrigi-lo.
    Acerto: Fornecer mensagens de erro claras e informativas que indicam o problema, destacam a localização do erro e oferecem orientações específicas sobre como corrigi-lo, facilitando a recuperação dos usuários após cometerem um erro.

#### 10. <b> Ajuda e documentação </b>
    Erro: Depender excessivamente da ajuda e documentação, tornando a interface pouco intuitiva e frustrante para os usuários que precisam constantemente da ajuda externa.
    Acerto: Fornecer uma interface intuitiva e fácil de usar, com a ajuda e documentação disponíveis como recursos complementares para auxiliar os usuários quando necessário, permitindo que eles se tornem mais independentes na utilização do sistema.

# Atividade 4
### Diagrama de Caso de Uso:
<img src="https://github.com/LucasHCOliveira7/bertoti/assets/81196630/033647dc-21bf-4510-808c-da2ff8fb5505" height="500" width="700">

# Atividade 5
### Diagrama de Classe UML:
