# Atividade 1
### O que é Engenharia de Software?
#### TEXTO 1
We see three critical differences between programming and software engineering: time, scale, and the trade-offs at play. On a software engineering project, engineers need to be more concerned with the passage of time and the eventual need for change. In a software engineering organization, we need to be more concerned about scale and efficiency, both for the software we produce as well as for the organization that is producing it. Finally, as software engineers, we are asked to make more complex decisions with higher-stakes outcomes, often based on imprecise estimates of time and growth.

#### Meus comentários sobre o texto:
1. Existem três diferenças entre programação e engenharia de software, são elas: tempo, escala e jogo de trade-off;
2. TEMPO: Em um projeto os engenheiros de software se preocupam mais com a passagem do tempo e com a eventual necessidade de mudanças;
3. ESCALA: Em uma organização os engenheiros de software se preocupam mais com escala e eficiência, tanto para o software que produz quanto para a organização que o está produzindo;
4. TRADE-OFF: Um engenheiro de software é solicitado a tomar decisões mais complexas de alto risco, muitas vezes com estimativas imprecisas de tempo e crescimento.

#### TEXTO 2
Within Google, we sometimes say, “Software engineering is programming integrated over time.” Programming is certainly a significant part of software engineering: after all, programming is how you generate new software in the first place. If you accept this distinction, it also becomes clear that we might need to delineate between programming tasks (development) and software engineering tasks (development, modification, maintenance). The addition of time adds an important new dimension to programming. Cubes aren’t squares, distance isn’t velocity. Software engineering isn’t programming.

#### Meus comentários sobre o texto:
1. A programação é uma parte significativa da engenharia de software;
2. A programação é como você gera um novo software;
3. Tarefa de programação (desenvolvimento);
4. Tarefa de engenharia de software (desenvolvimento, modificação e manutenção);
5. A adição do tempo adiciona uma nova dimensão importante a programação: Cubos não são quadrados, distância não é velocidade e engenharia de software não é programação;

# Atividade 2
### Exemplos de trade-off
1. <b> Portabilidade X Simplicidade: </b>
   O trade-off entre portabilidade e simplicidade envolve escolher entre uma linguagem de programação que é altamente portátil e pode rodar em várias plataformas, mas pode ser mais complexa, ou uma linguagem mais simples de entender e escrever, mas que pode não ser tão portátil. Como Java e Python, por exemplo.
   
3. <b> Usabilidade X Segurança: </b>
   O trade-off entre usabilidade e segurança ocorre quando desenvolver um software que é altamente usável pode comprometer a segurança e vice-versa. Usabilidade envolve facilitar a experiência do usuário, enquanto segurança envolve proteção contra ameaças. Como aplicativos de mensagens e redes sociais, por exemplo.
   
5. <b> Escalabilidade X Complexidade: </b>
   O trade-off entre escalabilidade e complexidade envolve escolher entre um sistema mais simples e fácil de entender, porém potencialmente menos escalável, e um sistema mais complexo, capaz de lidar com demandas maiores, mas também mais difícil de manter e depurar. Como programas de streamings (Netflix, Disney+, HBO, entre outros), por exemplo.

# Atividade 3
### 10 Heurísticas de Usabilidade para Design de Interface de Usuário
    https://www.nngroup.com/articles/ten-usability-heuristics/
    
### Encontre um erro e um acerto de cada heurística:
#### 1. <b> Visibilidade do Status do Sistema </b>
    Erro: Um aplicativo de entrega de comida não fornece informações sobre o status do pedido depois que ele é feito.
    Acerto: "rastreamento de entrega" em aplicativos de entrega, como o Uber Eats, Rappi ou iFood. O usuário pode ver se o pedido foi recebido, se está sendo preparado ou se saiu para entrega
<img src="https://github.com/LucasHCOliveira7/bertoti/assets/81196630/277294e9-3091-4278-b1b5-1c47654bb37a" width="500" heigth="400">
<img src="https://github.com/LucasHCOliveira7/bertoti/assets/81196630/e38e6733-147b-4577-9a06-b7d47961590d" width="200" heigth="400">

#### 2. <b> Compatibilidade entre o sistema e o mundo real </b>
    Erro: Aplicativo de edição de texto que usa ícones pouco intuitivos ou termos técnicos que não são familiares para os usuários comuns.
    Acerto: Design do aplicativo Google Maps. Esse aplicativo usa ícones e símbolos que são compreendidos, como setas para indicar direções ou ícones de marcadores para representar locais.
<img src="https://github.com/LucasHCOliveira7/bertoti/assets/81196630/9b3343a4-81a3-49ed-8cad-7b7f1932ab23" width="500" heigth="400">
<img src="https://github.com/LucasHCOliveira7/bertoti/assets/81196630/5b1ba988-e15d-461f-be3e-033d65bd1024" width="400" heigth="300">

#### 3. <b> Controle e liberdade para o usuário </b>
    Erro: Aplicativo de formulário online que não oferece a opção de voltar ou corrigir informações antes de finalizar o envio.
    Acerto: Plataforma de e-commerce, como a Amazon, que oferecem um processo de compra com etapas claras e a opção de revisar e editar o pedido antes de finalizá-lo.
<img src="https://github.com/LucasHCOliveira7/bertoti/assets/81196630/7b65516e-8b61-4085-befb-d6e775c5695d" width="500" heigth="400">
<img src="https://github.com/LucasHCOliveira7/bertoti/assets/81196630/d9200242-98e6-45f9-840a-8ede4394abe4" width="500" heigth="400">

#### 4. <b> Consistência e Padronização </b>
    Erro: Aplicativo de mensagens que usa símbolos diferentes para indicar a mesma ação em telas diferentes. Por exemplo, em uma tela de conversa, o ícone de "enviar" pode ser representado por um avião de papel, enquanto em outra parte do aplicativo, é representado por uma seta.
    Acerto: Aplicativos de redes sociais, como o Facebook ou Instagram. Essas plataformas mantêm a consistência no uso de ícones, cores e design em todo o aplicativo.
<img src="https://github.com/LucasHCOliveira7/bertoti/assets/81196630/465c9156-0857-438d-8ab2-e9a4bb5cff08" width="500" heigth="400">
<img src="https://github.com/LucasHCOliveira7/bertoti/assets/81196630/a4167218-e6f7-4ecb-8c7c-a932c7e09a50" width="500" heigth="400">

#### 5. <b> Prevenção de erros </b>
    Erro: Dependência exclusiva da prevenção de erros, sem oferecer feedback quando os erros ocorrem, deixando os usuários confusos.
    Acerto: Equilibrar a prevenção de erros com feedback eficaz quando os erros ocorrem, fornecendo medidas preventivas e instruções claras para ajudar os usuários a entender e corrigir os problemas. Isso resulta em uma experiência mais satisfatória.

#### 6. <b> Reconhecimento em vez de memorização </b>
    Erro: Sobrecarregar a interface com muitas dicas visuais, tornando-a confusa e desordenada.
    Acerto: Encontrar um equilíbrio entre fornecer dicas visuais para que os usuários possam reconhecer padrões e elementos familiares na interface, sem exagerar e manter a interface clara e simples. Isso facilita a navegação e o uso da aplicação.

#### 7. <b> Eficiência e flexibilidade de uso </b>
    Erro: Focar exclusivamente nas necessidades de um grupo de usuários (leigos ou experientes) em detrimento do outro, o que pode levar a uma interface inadequada para um público mais amplo.
    Acerto: Projetar uma interface flexível que atenda tanto aos iniciantes quanto aos usuários experientes, oferecendo uma experiência amigável e informativa para os primeiros e recursos avançados e atalhos para os últimos, proporcionando uma experiência eficaz e adaptável para todos.

#### 8. <b> Estética e design minimalista </b>
    Erro: Priorizar demais a estética e o minimalismo, sacrificando a usabilidade e removendo informações importantes, o que pode levar a uma experiência confusa para os usuários.
    Acerto: Adotar um design minimalista que elimine informações desnecessárias, mantendo o foco nas informações essenciais, desde que isso não prejudique a usabilidade e a acessibilidade da interface. Isso ajuda a tornar a interface mais eficiente ao transmitir informações importantes de forma clara.

#### 9. <b> Ajude os usuários a reconhecerem, diagnosticarem e recuperarem-se de erros </b>
    Erro: Fornecer mensagens de erro vagas e pouco informativas que não ajudam os usuários a entender o problema ou como corrigi-lo.
    Acerto: Fornecer mensagens de erro claras e informativas que indicam o problema, destacam a localização do erro e oferecem orientações específicas sobre como corrigi-lo, facilitando a recuperação dos usuários após cometerem um erro.

#### 10. <b> Ajuda e documentação </b>
    Erro: Depender excessivamente da ajuda e documentação, tornando a interface pouco intuitiva e frustrante para os usuários que precisam constantemente da ajuda externa.
    Acerto: Fornecer uma interface intuitiva e fácil de usar, com a ajuda e documentação disponíveis como recursos complementares para auxiliar os usuários quando necessário, permitindo que eles se tornem mais independentes na utilização do sistema.

# Atividade 4
### Diagrama de Caso de Uso:
<img src="https://github.com/LucasHCOliveira7/bertoti/assets/81196630/58581a11-1e0c-4952-8971-131b231a62f0" height="500" width="600">

# Atividade 5
### Diagrama de Classe UML:
<img src="https://github.com/LucasHCOliveira7/bertoti/assets/81196630/121f1128-c352-44aa-a3c1-77d9660ac68a" height="450" width="1000">

# Atividade 6
### Código Java (espelhando as classes UML)
Acesse [aqui](https://github.com/LucasHCOliveira7/bertoti/tree/main/engenhariaSW/DiagramaClasseUML/src/biblioteca) o código da classe Biblioteca

# Atividade 7
### Testes JUNIT
